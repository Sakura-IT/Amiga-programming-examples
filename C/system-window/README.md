# System Window

Opens an empty system window on the Workbench screen. Then waits for closing the window with the close gadget. It also illustrates the following:
* Minimal startup code instead of the standard one.
* Usage of tag based API functions.
* Simple makefile of the project for GNU Make.

The project has been compiled with Amiga native GCC 2.95.3. Note that the program requires Kickstart 3.0+, it will exit on older kickstart. System version check is implemented by requiring _dos.library_ v39+ in the startup code.

### Opening a window

Windowing system of the Amiga has two levels. Lower level is _layers.library_, which deals with rectangle, arbitrarily overlapped fragments of screen. Usually applications do not use _layers.library_ directly. Upper level of windowing system is _intuition.library_ which also handles user input and provides primitives for gadgets aka user controls.

The _intuition.library_ provides two calls for window creation.
* OpenWindow() is an older form, which takes window parameters as a fixed, prefilled structure. It works with all versions of AmigaOS.
* OpenWindowTags() is a modern form. It takes window parameters as a taglist. Taglist is an array of key-value pairs. The function builds tag array from variable arguments. This function has been introduced in the system v2.0. I use this form, as it is easier to use. One has to specify only attributes with non-default values.

In the example I use tags to specify following window properties:
* Inner (inside borders) width and height in pixels. Thickness of window borders depends on user preferences like display mode, screen font and so on. When inner values are specified, space for borders is added automatically.
* Standard gadgets for window closing, depth arranging and the title bar (also used to move the window by dragging).
* Window title, displayed on the title bar.
* Accepted categories of window messages (usually generated by user input). In this example I only accept IDCMP_CLOSEWINDOW messages. A message of this category is generated when user closes the window with the close gadget.

### Handling window messages

The _intuition.library_ receives input events and handles tasks like window activation, border redrawing, depth arranging and so on. If an input event generates a message for given window and opening application has requested given message category, the message will be put to window's message port named UserPort. By default UserPort of a window generates a signal for window owner process. Then our process need not to poll the port, it can just Wait() for the port signal, then get message(s) from the port and process them.

When the user clicks the window close gadget, _intuition.library_ generates message of IDCMP_CLOSEWINDOW category. As we have requested this category at window creation, a message will be put to our window UserPort, then a signal will be triggered.

The program opens the window, then extracts signal number from UserPort and converts it to signal mask (each process can have up to 32 signals, each signal is a bit in 32-bit word). Then program enters Wait(), which suspends the process until a signal matching Wait() signal mask arrives.

Wait() returns a mask of signals received. If UserPort signal bit is set in the mask, messages are read from the port in an inner loop. Note that signal from port does not correspond to exactly one message, there can be any number of messages waiting (including zero). That is why the inner loop is needed.

### Handling CTRL-C signal


### Startup code

### Makefile
